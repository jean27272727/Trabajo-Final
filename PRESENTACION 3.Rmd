---
title: "Precentacion3"
date: '2022-06-12'
output:
  rmdformats::readthedown:
    code_folding: show
  html_document:
    df_print: paged
  lightbox: yes
  toc: yes
  toc_depth: 5
  toc_float:
    collapsed: no
    smooth_scrool: yes
  thumbnails: yes
  self_contained: yes
---

```{r setup, include=FALSE, message=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**REPOSITORIO GITHUB: https://github.com/jean27272727/Trabajo-Final.git**


```{r message=FALSE, echo=FALSE, include=FALSE}
library(rio)
library(Rmisc)
library (stargazer)
library(moments)
library(DescTools)
library(BBmisc)
library(cluster)
library(factoextra)

TRABAJO1 =import("https://github.com/jean27272727/Trabajo-Final/blob/main/TRABAJO1.xlsx?raw=true")

#dato: el funcionamiento del gobierno como varaible dependiente. 
```


```{r message=FALSE, echo=FALSE, include=FALSE}
#Limpiamos y recodificamos la data 


export(TRABAJO1, "TRABAJO1.csv")
TRABAJO1= import("TRABAJO1.csv", encoding = "UTF-8")
head(TRABAJO1)
TRABAJO1$pais= substr(TRABAJO1$pais, 3, 100)
```

# INTRODUCCIÓN Y OBJETIVOS:

El presente trabajo tiene como objetivo presentar la regresión existente entre la funcion del gobierno, como la variable dependiente, y diferentes tipos de variables que pueden llegar a a fectarla Y predecirla en futuros casos no particulares. En este sentido, dichas varaibles independientes son:  participacion politica, cultura politica y libertades civiles. Para dar explicación a ello se creó diferentes tipos de regreciones múltiple incluyendo dos o mas de dichas variables independientes. Ademas, se presenta dos escalas de clausterización. En priemr lugar sobre una sola base de datos y, en segundo lugar, sobre dos base de datos. 




# ANÁLISIS DE REGRESIÓN

Para el proceso de análisis de regresión, se tomó en consideración realizar cuatro diferentes modelos: 

# ELACION 1: ENTRE 2 INDEPENDIENTES Y UNA DEPENDIENTE

## relacion entre funcionamiento_del_gobierno, participacion politica y libertades civiles  : modelo 4
```{r message=FALSE, echo=FALSE}
modelo4= lm(TRABAJO1$funcionamiento_del_gobierno~TRABAJO1$participacion_politica+TRABAJO1$libertades_civiles)
summary(modelo4)

```



# Relacion entre funcionamiento_del_gobierno, participacion politica, libertades civiles y cultura politica : modelo 5

```{r message=FALSE, echo=FALSE}
# Regla de control, mientras agregue más variables siempre tiene que aumentar. La varaible participacion politica no aporta al modelo porque mi r2 ajustado disminuye.

modelo5 = lm(TRABAJO1$funcionamiento_del_gobierno~TRABAJO1$participacion_politica+TRABAJO1$libertades_civiles+TRABAJO1$cultura_politica)
summary(modelo5)
# la variable: participacion politica peude ser una variable espuria (no tiene nada que ver) o tal vez dicha variable esta incluida en las otras dos.
```

## Explicacion del porqué de la caida del modelo donde estan incluidas la participacion politica y las libertades civiles


```{r}
cor.test(TRABAJO1$participacion_politica,TRABAJO1$libertades_civiles)

#conclución: Existe una correlacion muy fuerte entre las varaibles participacion politica y libertades civiles. La correalcion es 0.7924591. En este sentido, si se mantiene como constante (todos los paises tienen el mismo nivel) la participacion política deja de tener un efecto. Esto se explica posiblemente porque la participacion politica depende mucho de las libertades civiles del pais. Ademas, las unidades de analisis de las variables son diferentes (the economics, 2020).  
```
# Relacion donde estan incluidas libertades civiles y participacion politica

```{r message=FALSE, echo=FALSE}
library(stargazer)
stargazer(modelo4,modelo5,type = "text",no.space = F,digits =3,digit.separator="")
```
## Relacion entre funcionamiento_del_gobierno, libertades civiles y cultura politica : modelo 6
```{r}
modelo6= lm(TRABAJO1$funcionamiento_del_gobierno~+TRABAJO1$libertades_civiles+TRABAJO1$cultura_politica)
summary(modelo6)
# segun el p valor de cada una de mis variables aportan a mi modelo.Ademas, el  p-value general < 2.2e-16, es menor a 0,05. En este sentido, se rechaza la hipotesis nula y se concluye que el modelo sí es valido. 
# el Rcuadrado explica un 72,9%
```
# RELACION  2: 3 INDEPENDIENTES Y UNA DEPENDIENTE
## Relacion entre funcionamiento_del_gobierno, participacion politica y cultura politica : modelo 7

```{r}
modelo7= lm(TRABAJO1$funcionamiento_del_gobierno~+TRABAJO1$participacion_politica+TRABAJO1$cultura_politica)
summary(modelo7)
# segun mi p valor de cada una de mis variables aportan a mi modelo.ademas, el  p-value general < 2.2e-16, es menor a 0,05. Entonces, se rechaza la hipotesis nula y se concluye que el modelo sí es valido. 
# el Rcuadrado explica un 58,64%
```
# Nivel explicativo de ambos modelos



```{r}
tanova=anova(modelo6, modelo7)
stargazer(tanova,type = "text", summary = F, title = "Table de Análisis")
```

```{r}
modelo6$coefficients

#la formula sería:   Funcionamiento del gobierno=  -0.4333345 + 0.6941675(libertades civiles)+ 0.2485963(cultura politica)

# A partir del analisis entre el modelo 6 y 7 se concluye que el modelo 6 es más explicativo (explica mejor el funcionamiento del gobierno) que el modelo 7, en base a su r2, y presenta menor error estandar residual. En este sentido, se trabajará con el modelo 6. Es por ello que se procede a diagnosticar la regresion de dicho modelo para demostrar que es adecuado. Ver anexo 1.
```



# PREPARACIÓN DE LA DATA PARA SER CLUSTERIZADA

## Análisis de conglomerado

```{r message=FALSE, echo=FALSE}
library(cluster)
dataclous= TRABAJO1 [,-1]
row.names(dataclous)=TRABAJO1$pais
g.dist = daisy(dataclous, metric="gower")
```




** Cuadro de correlaciones en anexos. 

### PARA PAM: 
```{r}

library(factoextra)
fviz_nbclust(dataclous, pam,diss=g.dist,method = "gap_stat",k.max = 10,verbose = F)
```
 
### PARA Agnes
 
```{r}

fviz_nbclust(dataclous, hcut,diss=g.dist,method = "gap_stat",k.max = 10,verbose = F,hc_func = "agnes")
```



### PARA DIANA
```{r}

fviz_nbclust(dataclous, hcut,diss=g.dist,method = "gap_stat",k.max = 10,verbose = F,hc_func = "diana")
```


```{r message=FALSE, echo=FALSE}
###pam
set.seed(123)
grupos=4 
res.pam=pam(g.dist,k = grupos,cluster.only = F)
dataclous$pam=res.pam$cluster

###agnes
res.agnes<- hcut(g.dist, k =grupos,hc_func='agnes',hc_method = "ward.D")
dataclous$agnes=res.agnes$cluster

### diana
res.diana <- hcut(g.dist, k = grupos,hc_func='diana')
dataclous$diana=res.diana$cluster
```

```{r}
#Se utiliza AGNES, fijarse en el anexo 2
fviz_silhouette(res.agnes)
```

```{r}
# Encontremos los casos MAL clusterizados (silueta negativa):

library(magrittr)

silPAM=data.frame(res.pam$silinfo$widths)
silPAM$country=row.names(silPAM)
poorPAM=silPAM[silPAM$sil_width<0,'country']%>%sort()

silAGNES=data.frame(res.agnes$silinfo$widths)
silAGNES$country=row.names(silAGNES)
poorAGNES=silAGNES[silAGNES$sil_width<0,'country']%>%sort()

silDIANA=data.frame(res.diana$silinfo$widths)
silDIANA$country=row.names(silDIANA)
poorDIANA=silDIANA[silDIANA$sil_width<0,'country']%>%sort()

###
library("qpcR") 
mal_Clus=as.data.frame(qpcR:::cbind.na(poorPAM, poorAGNES,poorDIANA))
mal_Clus
```

```{r}
#Podemos usar teoría de conjuntos para ver qué los casos mal clusterizados en todos las técnicas:
intersect(poorPAM,poorAGNES)

setdiff(poorAGNES,poorPAM)
```

#GRAFICO SEGUN AGNES
```{r}
original=aggregate(.~ pam, data=dataclous,mean)
original

```
```{r}
dataclous$agnes=dplyr::recode(dataclous$pam, `3` = 1, `4`=2,`2`=3,`1`=4)
```


```{r}
#proyectando los casos en dos dimensiones:

proyeccion = cmdscale(g.dist, k=2,add = T) # k es la cantidad de dimensiones
dataclous$dim1 <- proyeccion$points[,1]
dataclous$dim2 <- proyeccion$points[,2]
base= ggplot(dataclous,aes(x=dim1, y=dim2,label=row.names(dataclous))) 
base + geom_text(size=2, aes(color=as.factor(diana)))  + labs(title = "AGNES") 
```



# CLUSTERIZACIÓN de data amiga

Para poder realizar el procesod e clusterización es necesario, primero


```{r}
library(rio)
data_marco= import("DATA1.xlsx")
names(data_marco)
data_marco=data_marco[ ,-1]

str(data_marco)
```

```{r message=FALSE, echo=FALSE, include=FALSE}
library(stringr)
#Borrar datos perdidos

data_marco$handwashing = as.numeric(data_marco$handwashing)
data_marco$mortality_rate = as.numeric(data_marco$mortality_rate)
data_marco$incidence_tuberculosis = as.numeric(data_marco$incidence_tuberculosis)
data_marco= na.omit(data_marco)

export(data_marco,"data_marco.xlsx")
```



```{r message=FALSE, echo=FALSE, include=FALSE}
colnames(data_marco)=c("pais","Acceso_al_lavado_de_manos","tasa_de_mortalidad","incidencia_de_tuberculosis")
```




```{r message=FALSE, echo=FALSE, include=FALSE}
merge(TRABAJO1, data_marco,"pais")
merge(TRABAJO1, data_marco,by="pais", sort=F)
merge(TRABAJO1, data_marco,by="pais", all.x=TRUE)

Data_claus=merge(TRABAJO1,data_marco, "pais")
```



```{r message=FALSE, echo=FALSE, include=FALSE}
boxplot(Data_claus[,-1])
```

** Cuadro de correlaciones en anexos. 

```{r message=FALSE, echo=FALSE}
boxplot(normalize(Data_claus[,-1],method='standardize'))
Data_claus[,-1]=normalize(Data_claus[,-1],method='standardize')
```
```{r message=FALSE, echo=FALSE, include=FALSE}
cor(Data_claus[,-1])
Data_claus$Acceso_al_lavado_de_manos=-1*Data_claus$Acceso_al_lavado_de_manos
```


```{r}
#POR LA FORMA EN QUE SE LLEVA LA CUSLTERIZACIÓN, ES NECESARIO ELIMINAR LA COLUMNA QUE LLEVA EL NOMBRE DE LOS PAÍSES.


row.names(Data_claus)=Data_claus$country
Data_claus=Data_claus[,-1]
```

# CLUSTERIZACIÓN

Para poder realizar el procesod e clusterización es necesario, primero, 

```{r message=FALSE, echo=FALSE, include=FALSE}
g.dist = daisy(Data_claus, metric="gower")
```

```{r message=FALSE, echo=FALSE, include=FALSE}
fviz_nbclust(Data_claus, hcut,diss=g.dist,method ="gap_stat",k.max =10,verbose =F,hc_func ="agnes")
```

```{r message=FALSE, echo=FALSE, include=FALSE}
###pam
set.seed(123)
grupos=2
res.pam1=pam(g.dist,k = grupos,cluster.only =F)
Data_claus$pam1=res.pam1$cluster

###agnes
res.agnes1<- hcut(g.dist, grupos,hc_func='agnes',hc_method ="ward.D")
Data_claus$agnes1=res.agnes1$cluster

### diana
res.diana1 <- hcut(g.dist, k = grupos,hc_func='diana')
Data_claus$diana1=res.diana1$cluster
```

#se observa en la siguiente proyección, los dos clusters seleccionados:

```{r message=FALSE, echo=FALSE, include=FALSE}
proyeccion = cmdscale(g.dist, k=2,add =T)
Data_claus$dim1 <- proyeccion$points[,1]
Data_claus$dim2 <- proyeccion$points[,2]
base= ggplot(Data_claus,aes(x=dim1, y=dim2,label=row.names(Data_claus)))
base + geom_text(size=2, aes(color=as.factor(agnes1))) + labs(title ="AGNES")
```
# Anexos

#Anexo 1

#diagnostico de la regresion del modelo 6


```{r}
#Linealidad

plot(modelo6, 1)
#la linea tienden a la horizontalidad por lo cual es aceptable. 
```

```{r}
#Homoceasticidad

plot(modelo6, 3)
# como la linea roja tiende a la horizontalidad el modelo es aceptable. 
```



```{r}
#Normalidad de residuos 
plot(modelo6, 2)
# los puntos estan cerca a la diagonal, por tanto la diferencia entre apropiaciondolar y apropiaciondolar se destribuye de manera normal
```
```{r}
shapiro.test(modelo6$residuals)
```


```{r}
# multicolinealidad
library(DescTools)
VIF(modelo6) #como los valores son menores a 5 se concluye que no presenta multicolinealidad.
```

```{r}
#valores influyentes
plot(modelo6, 5)
```
```{r}
#casos influyentes
checkmodelo6=as.data.frame(influence.measures(modelo6)$is.inf)
head(checkmodelo6)
```

```{r}
checkmodelo6[checkmodelo6$cook.d & checkmodelo6$hat,]
# se concluye que no presenta valores influyentes. 
```

#ANEXO 2
```{r}
# CONCLUCION ANEXO 3: el metodo AGNES es mejor porque presenta un mejor resultado: su promedio es 0,32; por ende presenta una mejor conglomeracion. 

fviz_silhouette(res.pam)
```
```{r}
fviz_silhouette(res.agnes)
```
```{r}
fviz_silhouette(res.diana)
```
#Anexo 3
```{r}

fviz_silhouette(res.pam1)
```


```{r}
fviz_silhouette(res.diana1)
```